---
title: http
tags:
---

## OSI

- 应用层：为应用程序提供服务。HTTP、SMTP、FTP、Telnet、DNS
- 表示层：数据格式转化和加密
- 会话层：会话管理、访问验证
- 传输层：提供两个主机端到端的数据传输服务
- 网络层：IP寻址和路由
- 数据链路层：在两个相邻节点传送数据时，将数据组合成数据帧，帧是数据链路层的传输单位
- 物理层：传送比特流

![image-20200629210557025](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200629210557025.png)

## Http协议

客户端和服务器之间数据传输的格式规范，全称超文本传输协议，位于应用层(第7层)

### 无状态

无状态协议对于事务处理没有记忆能力

**解决**

- Cookie

- 通过session会话保存

### 组成

请求报文包含四部分：

- 请求行：协议名称及版本、请求方法、url
- 请求头：Content-Length(必须)、Authorization、Host、Cookie
- 空行
- 请求体：如果是get，为空

响应报文包含四部分：

- 响应行：协议及版本、状态码
- 响应头：set-cookie
- 空行
- 响应体

### HTTP1.1 

- 默认使用长连接
- 流水线处理：在一个连接传送多个请求
- 添加host字段

### HTTP2.0

- 头部压缩
- 二进制分帧：在应用层和传输层之间加了二进制分帧层，是数据传输的最小单位，以二进制传输代替明文传输，每帧的stream identifier标明这一帧属于哪个流
- 多路复用：在一个连接传送多个请求，接收方根据流标识拼接数据
- 请求优先级设置

## 数据传输过程

发送方从高层向底层封装数据：

- 应用层把数据转换为二进制
- 传输层的TCP将数据分割，并封装TCP报文头部
- 网络层将数据封装上IP头部
- 数据链路层将数据封装上MAC头部
- 物理层将数据转化为电信号

接收方反过来

## 输入url完整请求过程

1. 通过DNS解析获取服务器IP
2. 建立TCP连接。Http是应用层协议，比TCP层次更高。根据规则，要先建立低层次协议
3. 发送HTTP请求
4. 服务器收到请求并应答，发送响应报文
5. 服务器关闭TCP连接
6. 浏览器解析渲染页面

## DNS解析过程

![img](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/20171211190812796.png)

1. 浏览器检查缓存
2. 操作系统检查hosts
3. LDNS本地域名服务器
4. 根域名服务器返回顶级域名服务器(.com .cn)
5. LDNS向顶级域名服务器发起请求，返回域名对应的Name Server地址，就是网站注册的域名服务器
6. Name Server根据映射关系表找到ip，返回给LDNS
7. LDNS缓存ip，并将结果返回给用户
8. 用户缓存到本地

## Cookie Session Token

**cookie**

是存在浏览器的标识用户的方式，由服务器为每个用户签发不同的session id发送给浏览器存储在cookie中，下次访问带上这个cookie

CSRF攻击，单个cookie保存的数据不能超过4k，很多浏览器都限制站点保存的cookie数量。

不可跨域：domain属性表示Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。

重要属性：

- name=value：cookie的名称和值
- domain：cookie所属域名
- path：指定cookie在哪个路径下生效，默认"/"
- httpOnly：设置了这个属性，则无法通过js脚本获取该cookie的信息

**session**

session是存在服务器的标识用户的方式，服务器为每个用户生成不同的session id和响应的信息

在分布式系统中，session不能共享；服务器要保存所有用户的session id，压力大

**token**

服务器签发一个令牌发给浏览器，浏览器每次访问的时候将令牌加入Authorization header中，形式是Bearer{JWT}，服务器解码JWT然后验证token，

## URI、URL、URN

URI(Uniform Resource Identifier)统一资源标识符，用来唯一标识一个资源，类似身份证号

URL(Uniform Resource Location)统一资源定位符，提供资源的路径，是一种具体的URI。不仅可以标识资源，还可以定位资源

## 常见状态码

200：正常

301：永久重定向

302：临时重定向

304：内容无变化

400：客户端请求错误

401：请求需要认证

403：请求的资源被禁止访问

404：服务器无法找到资源

500：服务器内部错误

503：服务器正忙

## Get和Post区别

GET把参数包含在URL中，POST通过请求体传递参数

GET会被浏览器缓存，POST不会

本质都是TCP连接，但是GET产生一个TCP数据包，而POST产生两个

对于GET，浏览器会把header和data一起发送出去

对于POST，浏览器会先发送header，然后再发送data。火狐除外

## Https

### 安全性

1. 通过**加密**防止被窃听
2. 通过**摘要**防止被篡改
3. 通过**证书**防止被伪装

### 加密

如果加密和解密秘钥相同，称为对称加密

非对称加密：私钥+公钥=秘钥对，用私钥加密的数据只有对应的公钥才能解开，用公钥加密的数据只有对应的私钥才能解开

**优缺点**

对称加密对CPU的消耗更少，速度更快。但是对称加密需要将秘钥发送给另一方，如果被截获就完了

非对称加密安全性更高，但是速度慢，影响性能

**混合加密**

HTTPS使用混合加密机制。在秘钥交换阶段使用非对称加密，之后通信阶段使用对称加密

### 数字签名

将内容进行hash计算，得到摘要。这一过程能保证：

1. 过程不可逆
2. 摘要不会重复。如果内容被更改，再次hash计算的摘要一定不会和之前的一样

然后使用私钥对摘要进行加密，加密后的结果就是数字签名

![image-20200109141321675](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200109152646515.png)

接收方收到以后

1. 使用公钥将数字签名解密，如果成功，说明数字签名没被更改
2. 对内容进行hash计算，和解密数字签名得到的摘要进行对比，如果一致说明没有被更改

以上就是整个数字签名的过程，它能够保证发出的信息不被更改，也能证明确实是发送人发出的消息

### 数字证书

目前还有一个问题：无法确认公钥是真的公钥，有可能被冒充

数字证书是经过权威机构（CA）认证的公钥，可以确保公钥不被冒充

**生成流程**

1. 持有人将公钥及身份信息送给权威机构
2. 机构负责验证
3. 机构使用自己的私钥对持有人公钥进行加密，生成数字证书
4. 为了确保数字证书不被更改，对数字证书进数字签名，放到数字证书中

在收到内容后，用CA的公钥解密数字证书中的数字签名（CA公钥存在根证书中，根证书是绝对信任的），得到摘要，再计算数字证书的hash值，两者对比即可验证

### HTTPS通信过程

https://limboy.me/tech/2011/02/19/https-workflow.html

![image-20200109152646515](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200109141321675.png)

1. 客户端发起HTTPS请求，连接server的443端口
3. 服务器将数字证书（包含公钥）发送给客户端
4. 客户端使用根证书验证证书合法性。如果验证正确，那么客户端会生成一个随机值，这个随机值就是用于对称加密的秘钥，我们称之为客户端秘钥，然后用公钥进行非对称加密
5. 客户端将加密的客户端秘钥发送给服务器
6. 服务器收到密文后，用私钥进行非对称解密，解密的明文就是客户端秘钥，然后用客户端秘钥对数据进行对称加密
7. 服务器将密文发送给客户端
8. 客户端收到密文后用客户端秘钥进行对称解密，得到数据

### Http和Https的区别

1. http通讯使用明文，不验证对方身份，无法验证报文完整性，是不安全的
2. http标准端口是80，https是443
3. 在OSI模型中，http工作在应用层，而https的安全传输机制工作在传输层

## TCP/IP

是一个协议簇，分为应用层、传输层、网络层、网络接口层

**通信过程**

发送端从应用层往下走，传输层的TCP协议建立在IP协议之上，负责在发送端和接收端之间建立可靠连接。TCP协议将应用层的数据分割，进行编号，转发给网络层。位于网络层中的IP协议增加接收端的地址转发给链路层。

IP协议负责将数据包的接收和发送，但是不能保证将数据正确送达，所以要加上TCP协议

## TCP/UDP

传输层，负责向两台主机之间的通信提供数据传输服务

**区别**

1. TCP是面向连接的，基于字节流传输，使用流量控制和拥塞控制保证稳定传输，适用于要求可靠传输的场景，比如传输文件，UDP是无连接的、不可靠的、面向报文的，适用于实时应用
2. TCP只能一对一通信，UDP支持一对一、一对多、多对一、多对多
3. TCP报文头部20-60个字节，UDP报文头部小，仅8个字节，传输高效

## TCP全连接半连接

全连接队列取决于`somaxconn`（默认128）和`backlog`（默认511）的最小值



## TCP如何保证可靠性

https://www.iteye.com/blog/uule-2429131

### 校验和

检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 

### 序列号和确认号

TCP将数据分割并编号，用来确定数据传输的位置，提高可靠性

### 连接管理

三次握手四次挥手

### 超时重传

当 TCP 发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到这个确认，那么将重发这个报文段

### 流量控制

接收端在发送ACK报文时，会包含自己接收缓冲区的大小，发送端会根据这个值改变发送速度，防止包丢失，由滑动窗口协议实现。

**滑动窗口**

保证发送顺序，提高吞吐量

发送端的数据分为四类，发送窗口包含已发送未Ack和待发送未Ack两类，大小这里为7，实际是根据接收端报文动态调整。

TCP对一个或多个报文段发送一个ACK，比如说发送方有1/2/3 3个报文段，先发送了2,3 两个报文段，但是接收方期望收到1报文段，这个时候2,3报文段就只能放在缓存中等待报文1的空洞被填上，如果报文1，一直不来，报文2/3也将被丢弃，如果报文1来了，那么会发送一个ACK对这3个报文进行一次确认。


![sendWindowInit](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/sendWindowInit.png)

4号被确认，窗口右移将11号读进缓存

![send-window](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/send-window.png)

如果一直没有等到5号的Ack，就会重传

**死锁**

当发送者收到一个窗口长度为0的应答，就停止发送，等待接受者的另一个应答。但是如果这个不为0的应答在传输过程中丢失，发送者会一直等待，而接收者以为发送者已经收到应答，等待接收数据，双方都陷入等待。

TCP使用**持续计时器**，接收者每收到一个零窗口的应答就启动，时间一到便主动发送报文询问接收者的窗口大小。若接收者仍返回0窗口，则重置计时器继续等待；若窗口不为0，则表示应答报文丢失，重置发送窗口后继续发送

### 拥塞控制

慢开始、拥塞避免、快重传、快恢复

1. TCP引入了慢开始机制，发送方有一个拥塞窗口cwnd，在开始发送数据时先发送少量的数据，以指数规律进行增长

2. 为了控制拥塞窗口的增长，设置慢开始门限ssthresh。当拥塞窗口超过这个阈值，就执行拥塞避免算法，也就是拥塞窗口按线性进行增长。如果出现网络阻塞，ssthresh就减小为阻塞时拥塞窗口的一半

3. 快重传：接收方收到一个失序的报文段之后要立即发出重复确认，发送方只要一连收到三个重复确认就要立即重传接收方尚未收到的报文段
   ![image-20200501181546743](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200501181546743.png)

4. 快恢复：配合快重传算法使用。当发送发重传时，ssthresh减半，考虑到既然能收到三个重复确认报文，所以发送发认为网络可能没有阻塞，就不执行慢开始，而是将拥塞窗口设置为ssthresh，然后执行拥塞避免算法
   ![http-快恢复](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/http-%E5%BF%AB%E6%81%A2%E5%A4%8D.png)

   注意：在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用

## Tcp三次握手四次挥手

https://blog.csdn.net/qzcsu/article/details/72861891?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1

![image-20200405203609305](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200405191639519.png)

序列号seq：用来标记数据段(图中TCP数据部分)的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个数据字节的编号由本地随机产生，报文段的序列号就是数据段第一个字节的序号

确认号ack：期望收到对方下一个报文段的第一个数据字节的序号，是当前报文段最后一个字节的序号+1

ACK：ACK=1时ack才有效

FIN：请求断开连接

### 三次握手

![image-20200405191639519](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200405203609305.png)

最开始双方都是处于CLOSED状态

1. 第一次握手：客户端向服务器发出连接请求报文，SYN=1,seq=x，并且进入SYN-SENT状态，<font color='red'>该报文段不能携带数据，但需要消耗掉一个序号</font>
2. 第二次握手：服务器收到请求报文后，发出确认报文，SYN=1,ACK=1,seq=y,ack=x+1，并且进入SYN-RCVD状态，<font color='red'>该报文段不能携带数据，但需要消耗掉一个序号</font>
3. 第三次握手：客户端收到确认后，再次向服务器确认，确认报文的ACK=1,seq=x+1,ack=y+1，此时客户端和服务器建立TCP连接，进入ESTABLISHED状态，完成三次握手

### 四次挥手

![image-20200405212157544](https://raw.githubusercontent.com/zheyday/BlogImg/master/img/image-20200405212157544.png)

1. 客户端发出连接释放报文，并且停止发送数据。FIN=1，seq=u(等于前面已经传送过来的数据的最后一个字节的序号+1)，此时客户端进入FIN-WAIT-1(终止等待1)状态。<font color='red'>FIN报文段即使不携带数据，也需要消耗掉一个序号</font>
2. 服务器收到连接释放报文，发出确认报文，ACK=1，seq=v，ack=u+1，此时服务器进入CLOSE-WAIT(关闭等待)状态。TCP服务器通知高层的应用进程，客户端向服务器方向的连接就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是如果服务器要发送数据，客户端必须要接受。这个状态要持续一段时间，也就是CLOS-WAIT状态持续的时间
3. 客户端收到服务器的确认请求后，进入FIN-WAIT-2(终止等待2)状态，等待服务器发送连接释放报文(在这之前还要接受服务器的数据)
4. 服务器发送完最后的数据后，向客户端发送连接释放报文，FIN=1，seq=w，ack=u+1，此时服务器进入LAST-ACK(最后确认)状态，等待客户端确认
5. 客户端收到连接释放报文后，必须发出确认，ACK=1，seq=u+1，ack=w+1，客户端进入TIME-WAIT(时间等待)状态。注意此时TCP连接还没有释放，必须要等待2*MSL(最长报文段寿命)的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态
6. 服务器只要收到客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了本次TCP连接

### 为什么要三次握手

防止已经失效的连接请求突然又传到服务器，从而产生错误

如果使用的是两次握手，假如第一个连接请求因为网络原因阻塞过长时间，客户端又重新发送这条报文，经两次握手完成连接，传输数据然后关闭连接。此时上次滞留的请求到达了服务器，如果是两次握手，那么双方直接建立连接，这将导致错误和资源的浪费。

### 为什么连接时三次，关闭要四次

因为服务器收到客户端的连接请求报文后，可以直接发送SYN+ACK报文。

而关闭连接时，服务器收到FIN报文时，自己可能还有数据没有发送，所以ACK和FIN要分开发送

### 为什么客户端最后还要等待2MSL

- 防止上一次连接中的数据包重新出现，影响新连接
- 因为客户端发出的最后一个ACK报文可能会丢失，服务器如果没有收到ACK，会重复发送FIN报文，而客户端会在2MSL时间内收到这个重发的报文，接着发出确认报文，并重启2MSL计时器

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还有一个**保活计时器**，服务器每收到一次客户端的请求都会重新复位这个计时器，通常为2h，如果2h还没有收到客户端的任何数据，服务器就会每隔75s发送一个探测报文段，如果连续发送10个仍然没有反应，服务器就关闭连接



