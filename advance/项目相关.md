---
title: 项目相关
tags:
---

## OAuth2



## Leaf算法



## 分布式

### CAP理论

- 一致性(Consistency)：数据在多个副本之间保持一致性
- 可用性(Available)：系统提供的服务必须一直处于可用的状态，对于每一个请求总能在有限的时间内返回结果
- 分区容错性(Partition Tolerance)：在遇到网络分区故障的时候，分布式系统仍然能够保证对外提供一致性和可用性的服务

### BASE

- 基本可用(Basically Available)：保证核心可用
- 软状态(Soft State)：允许系统不同节点的数据副本之间在同步过程中存在时延
- 最终一致性(Eventually Consistent)：系统中所有的数据副本，在经过一段时候的同步后，最终达到一致性

## 分布式锁

### Redis的SETNX

### RedLock

使用多个Redis实例来实现分布式锁，保证高可用

- 从N个实例中获取锁



### Zookeeper

- 创建一个目录/lock
- 客户端获取锁时，在/lock下创建临时的有序子节点
- 获取/lock下的子节点列表，判断自己创建的是否为列表中最小的子节点，如果是则获得锁，否则监听前一个节点，得到通知后重复此步骤直到获取锁
- 业务完成后，删除对应的子节点

## 秒杀设计

### 前端

- 动静分离（项目是前后端分离），利用CDN缓存静态资源
- 秒杀开始前按钮变灰，开始后按钮点一次变灰，禁止用户重复提交请求。如果直接调用http请求，那么就限制不了了

### 动态链接

如果链接提前暴露，那么就可以通过脚本获取北京时间，在00毫秒时发送请求

### Nginx

- 恶意请求拦截：通过limit_req设置端口防刷，通过limit_conn限制ip的连接数
- 负载均衡
- 商品数量直接从redis中读取

### Redis集群

单机模式下lua脚本没问题，但是在集群下，如果多个key落在不同的slot上，那么会报错，所以要通过代码确保lua脚本中的keys都落在一个slot上，可以通过在key前面加`{1}`变为`{1}1`，就会根据`{1}`来计算slot

初始化时将商品数量加载到redis中，

### RabbitMQ

扣减库存成功之后写入RabbitMQ，然后写到数据库











